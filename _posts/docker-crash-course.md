---
title: "Docker: Rapido y Furioso"
excerpt: "Si Docker fuera una pel√≠cula, ser√≠a esa escena donde presionas el bot√≥n de NOS y te mueves a 300 km/hr. üöÄ Ajusta el cintur√≥n, porque este crash course va directo al grano para que containerices tu c√≥digo como un verdadero Toretto."
coverImage: "/assets/blog/docker-crash-course/cover.jpg"
date: "2025-02-20T17:28:57.211Z"
author:
  name: "Adrian Castillo"
  picture: "/assets/blog/authors/adrian.jpeg"
ogImage:
  url: "/assets/blog/docker-crash-course/cover.jpg"
preview: false
---


## TL;DR
Docker te permite empaquetar aplicaciones en contenedores ligeros que pueden ejecutarse en cualquier sistema sin preocuparte por dependencias. Con Docker Compose, puedes definir m√∫ltiples servicios (como una API y su base de datos) en un solo archivo `docker-compose.yml`. Este blogpost es una referencia r√°pida para recordarme c√≥mo usar Docker de manera efectiva sin perder tiempo buscando documentaci√≥n.


## üê≥ Introducci√≥n r√°pida a Docker

### üèó Containerizaci√≥n vs Virtualizaci√≥n
La containerizaci√≥n no es lo mismo que la virtualizaci√≥n. Mientras que una **m√°quina virtual (VM)** necesita un sistema operativo completo, un **contenedor** comparte el mismo kernel del host, haciendo que sea m√°s liviano y r√°pido. B√°sicamente, las VMs son como casas independientes, mientras que los contenedores son departamentos en el mismo edificio, compartiendo algunos recursos pero aislados entre s√≠.

### üîë Docker: La Magia de la Containerizaci√≥n
Imagina que est√°s desarrollando una aplicaci√≥n con dependencias espec√≠ficas. Configurar el entorno correcto en cada m√°quina puede ser un dolor de cabeza. Aqu√≠ es donde **Docker** brilla, empaquetando todo en **contenedores** que aseguran que tu aplicaci√≥n se ejecute de manera id√©ntica en cualquier lugar.

### üîó Complemento con **notdefined-workbench**
Si quieres ejemplos listos para levantar y probar diferentes tecnolog√≠as con Docker, revisa el repositorio [notdefined-workbench](https://github.com/rodacato/notdefined-workbench). Ah√≠ encontrar√°s configuraciones listas con `docker-compose.yml` para m√∫ltiples stacks.

### üîë Problemas que Docker resuelve

¬øA√∫n sigues confundido? Hagamos esto m√°s pr√°ctico. ¬øHas pasado por alguno de estos problemas?

- **"En mi m√°quina funciona, pero en producci√≥n no"** ‚Üí Docker encapsula todo, asegurando consistencia en cualquier entorno.
- **"Actualizar dependencias rompe otros servicios"** ‚Üí Cada contenedor tiene su propio entorno, sin interferencias, y puedes probar versiones antes de actualizar.
- **"Dificultad para compartir y mantener entornos de desarrollo"** ‚Üí Con solo compartir un `Dockerfile` o `docker-compose.yml`, cualquier equipo puede replicar tu entorno.
- **"Cada vez que agregan un nuevo servicio, tengo que reconfigurar mi m√°quina"** ‚Üí Docker Compose gestiona m√∫ltiples contenedores f√°cilmente, manteniendo todo sincronizado.

La clave de Docker es la **containerizaci√≥n**, empaquetando tu aplicaci√≥n y todas sus dependencias en un contenedor. Esto garantiza que la aplicaci√≥n se ejecute de manera consistente en cualquier m√°quina con Docker instalado.

No confundir con la **virtualizaci√≥n**, que crea m√∫ltiples entornos virtuales en una sola m√°quina f√≠sica. Docker no virtualiza un SO, sino que usa el mismo kernel del sistema host para crear contenedores ligeros.

## üîë Conceptos clave en Docker

- **Imagen**: Plantilla con c√≥digo, librer√≠as y configuraciones necesarias para crear un contenedor.
- **Contenedor**: Instancia en ejecuci√≥n de una imagen. Son aislados y predecibles.
- **Docker Engine**: Servicio que gestiona la ejecuci√≥n de contenedores.
- **Docker Hub**: Registro p√∫blico de im√°genes de Docker.
- **Dockerfile**: Archivo con instrucciones para construir una imagen Docker.
- **Volumen**: Almac√©n de datos persistente para evitar p√©rdida de informaci√≥n al eliminar contenedores.
- **Red**: Permite la comunicaci√≥n entre contenedores y con el host.


## üèó Instalaci√≥n de Docker (Mac/Linux)
Para instalar Docker en Linux o macOS, simplemente ejecuta:
```sh
curl -fsSL https://get.docker.com | bash
```
Para verificar que Docker se instal√≥ correctamente:
```sh
docker --version

# Tambien puedes correr el hello-world
docker run hello-world
```

Ejemplo r√°pido para correr un contenedor de **PostgreSQL**:
```sh
docker run --name postgres -e POSTGRES_PASSWORD=secret -d postgres
```
Para ver los contenedores en ejecuci√≥n:
```sh
docker ps
```

### üéâ ¬°Felicidades, tu primer contenedor est√° corriendo! ¬øAhora qu√©?

Puedes conectarte a PostgreSQL dentro del contenedor, ver logs o persistir los datos usando vol√∫menes.

Para conectarte desde la terminal:
```sh
docker exec -it postgres psql -U postgres
```

Para ver logs:
```sh
docker logs postgres
```

Para evitar perder datos cuando detengas el contenedor:
```sh
docker stop postgres

docker rm postgres

docker run --name postgres -e POSTGRES_PASSWORD=secret -v pg_data:/var/lib/postgresql/data -d postgres
```

Si quieres conectarte con un cliente como `psql` desde tu m√°quina:
```sh
docker run --name postgres -e POSTGRES_PASSWORD=secret -p 5432:5432 -d postgres
```
Luego puedes acceder con:
```sh
psql -h localhost -U postgres
```

## üìå Ejemplo Completo

¬øQuieres ensuciarte las manos a√∫n m√°s? Ahora hagamos un ejemplo m√°s completo: vamos a crear una API en Node.js.

Este ser√° nuestro proyecto:

```
mi-app/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ package.json
```

### `index.js`
```js
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello from Docker!');
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on port ${PORT}`);
});
```

### `package.json`
```json
{
  "name": "app",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "express": "^4.21.2"
  }
}
```

### `Dockerfile`
```dockerfile
# Usa la imagen oficial de Node.js
FROM node:18

# Establece el directorio de trabajo dentro del contenedor
WORKDIR /usr/src/app

# Copia los archivos necesarios
COPY package*.json ./

# Instala las dependencias
RUN npm install

# Copia el resto del c√≥digo de la aplicaci√≥n
COPY . .

# Expone el puerto 3000 para la API
EXPOSE 3000

# Comando de inicio
CMD ["node", "index.js"]
```

### üîπ  Construcci√≥n y Ejecuci√≥n del Contenedor
Para comenzar, primero tenemos que generar la imagen. Para ello, ejecutamos los siguientes comandos desde el directorio `app` (sin `docker-compose` por ahora):
```sh
docker build -t mi-app .
docker run -p 3000:3000 mi-app
```

Ahora puedes visitar `http://localhost:3000` para ver el servidor en funcionamiento. Para detener el contenedor:
```sh
docker stop <CONTAINER_ID>
```

### üîπ Usando `docker-compose`

Ahora probemos usando `docker-compose`. Vamos a crear el archivo `docker-compose.yml` fuera del directorio `app`, as√≠:

```
mi-app/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ package.json
```

### `docker-compose.yml`
```yaml
services:
  app:
    build: ./app
    container_name: node_app
    ports:
      - "3000:3000"
    networks:
      - backend
    volumes:
      - ./app:/usr/src/app

networks:
  backend:

volumes:
  pg_data:
```

Ahora podemos iniciar todo con un solo comando mucho m√°s f√°cil de recordar:
```sh
docker-compose up
```

Muy bonito, pero nada impresionante... Bueno, veamos una configuraci√≥n m√°s avanzada con base de datos y cach√©:

```yaml
services:
  db:
    image: postgres
    container_name: postgres_db
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mydatabase
    volumes:
      - pg_data:/var/lib/postgresql/data
    networks:
      - backend
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "user"]
      interval: 10s
      retries: 5
      timeout: 5s

  redis:
    image: redis:latest
    container_name: redis_cache
    networks:
      - backend

  app:
    build: ./app
    container_name: node_app
    depends_on:
      db:
        condition: service_healthy
    environment:
      DATABASE_URL: postgres://user:password@db:5432/mydatabase
    ports:
      - "3000:3000"
    networks:
      - backend
    volumes:
      - ./app:/usr/src/app

networks:
  backend:

volumes:
  pg_data:
```

Despu√©s de unos segundos de magia:
```sh
docker-compose up
```

¬°Voil√†! Ahora tenemos tres contenedores corriendo y comunic√°ndose entre s√≠ (`docker ps`):

```
CONTAINER ID   IMAGE          COMMAND
4c82eb429297   mi-app-app     "docker-entrypoint.s‚Ä¶"
9a37acac283f   postgres       "docker-entrypoint.s‚Ä¶"
7b0c27402fb5   redis:latest   "docker-entrypoint.s‚Ä¶"
```

Empiezas a ver los beneficios, ¬øverdad? ¬°Estupendo! Ahora imagina tus proyectos corriendo con un solo comando. Alucinante. No olvides detener `docker-compose`, y si quieres jugar con los archivos, puedes obtenerlos desde el repositorio `notdefined-benchmark`.



## üì¶ Vol√∫menes en Docker

Los vol√∫menes en Docker permiten persistir datos m√°s all√° del ciclo de vida de un contenedor. Algunas cosas clave que debes saber:

- **Persistencia de bases de datos:** Evita que los datos se borren al eliminar un contenedor.
- **Compartici√≥n de datos entre contenedores:** Dos o m√°s contenedores pueden acceder a un mismo volumen.
- **Optimizaci√≥n del rendimiento:** Los vol√∫menes son m√°s eficientes que los bind mounts.

Ejemplo de creaci√≥n de un volumen y asignaci√≥n a PostgreSQL:
```sh
docker run --name postgres -e POSTGRES_PASSWORD=secret -v pg_data:/var/lib/postgresql/data -d postgres
```

Para listar vol√∫menes:
```sh
docker volume ls
```

Para eliminar vol√∫menes no usados:
```sh
docker volume prune
```

## üåê Redes en Docker

Docker permite la comunicaci√≥n entre contenedores a trav√©s de redes personalizadas.

Ejemplo de creaci√≥n de una red y conexi√≥n de contenedores:
```sh
docker network create mi_red

docker run -d --name db --network=mi_red -e POSTGRES_PASSWORD=secret postgres

docker run -it --rm --network=mi_red alpine sh
```

Dentro del contenedor Alpine, puedes probar la conexi√≥n:
```sh
apk add --no-cache postgresql-client
psql -h db -U postgres
```

## üìâ Optimizaci√≥n de Im√°genes en Docker

La optimizaci√≥n de im√°genes en Docker es clave para reducir su tama√±o, mejorar la seguridad y acelerar despliegues. Aplicamos m√∫ltiples estrategias para mejorar nuestras im√°genes, pero alcanzamos un punto donde ya no hab√≠a mejoras en tama√±o. Esto indica que hemos eliminado lo innecesario y tenemos una imagen eficiente.

Hay varias estrategias esta lista es algunas de ellas:

- **Cambio a versiones alpine como `node:18-alpine`** para reducir el tama√±o base.
- **Uso de multi-stage builds** para copiar solo lo esencial a la imagen final (ejemplo no node_modules).
- **Eliminaci√≥n de dependencias innecesarias** con `npm install --only=production`.
- **Minimizaci√≥n de capas en el `Dockerfile`**.
- **Uso de `.dockerignore`** para evitar archivos innecesarios en la imagen final.


Despu√©s de aplicar estas optimizaciones, construimos diferentes versiones y verificamos su tama√±o con:
```sh
docker images | grep mi-app
```

Por ejemplo este `Dockerfile` optimizado:

```dockerfile
# Etapa 1: Builder
FROM node:18 AS builder
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .

# Etapa 2: Producci√≥n
FROM node:18-alpine
WORKDIR /usr/src/app
COPY --from=builder /usr/src/app/node_modules ./node_modules
COPY --from=builder /usr/src/app/index.js ./
EXPOSE 3000
CMD ["node", "index.js"]
```

Nos da estos resultados:
```
mi-app-original    latest    abc123456789   5 minutes ago   500MB
mi-app-opt         latest    def987654321   3 minutes ago   150MB
```

## üì° Logs & Monitoring en Docker

Porque ir a ciegas no es divertido, aqu√≠ tienes algunos comandos √∫tiles para ver qu√© est√° pasando antes de quedarte pel√≥n como Toretto.


### üîπ Ver logs de contenedores en tiempo real
```sh
docker logs -f nombre_del_contenedor
```
Esto es √∫til para monitorear la API en vivo sin necesidad de entrar al contenedor.

### üîπ Monitoreo de recursos en vivo
```sh
docker stats
```
Muestra el consumo de CPU, memoria y red de los contenedores en ejecuci√≥n.

### üîπ Acceder a un contenedor en ejecuci√≥n
```sh
docker exec -it nombre_del_contenedor sh
```
Si tiene `bash`, puedes usar:
```sh
docker exec -it nombre_del_contenedor bash
```

### üîπ Detectar contenedores fallidos
Si un contenedor se apaga inesperadamente:
```sh
docker ps -a
```
Si el c√≥digo de salida es `1`, revisa los logs:
```sh
docker logs nombre_del_contenedor
```

### üîπ Configurar logs en `docker-compose.yml`
```yaml
services:
  app:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```
Esto evita que los logs ocupen demasiado espacio.

### üîπ Ver logs de todos los servicios en `docker-compose`
```sh
docker-compose logs -f
```
Facilita la depuraci√≥n cuando hay m√∫ltiples servicios.

## üõ† Debugging en Docker

Mientras usemos Docker, no todo va a salir como esperamos. Para esos casos, hay que saber c√≥mo depurar. Aqu√≠ tengo unos tips para cuando ese momento llegue, y llegar√°.

### üîπ Ver contenedores en ejecuci√≥n
```sh
docker ps -a
```

### üîπ Revisar logs de un contenedor
```sh
docker logs nombre_del_contenedor
```

### üîπ Acceder a un contenedor en ejecuci√≥n
```sh
docker exec -it nombre_del_contenedor sh
```

### üîπ Reconstruir im√°genes desde cero
```sh
docker-compose build --no-cache
```

### üîπ Ver c√≥digos de salida
Si un contenedor sale inmediatamente despu√©s de ejecutarse, revisa su c√≥digo de salida:
```sh
docker ps -a
```

Si el estado es `Exited (0)`, significa que el proceso termin√≥ correctamente, pero no ten√≠a un proceso en segundo plano para mantenerlo vivo.

### üîπ Limpiar Docker de im√°genes y contenedores no usados
```sh
docker system prune -a -f
```

## üî• Limpiar el entorno de Docker

A medida que usas Docker, los contenedores, im√°genes, vol√∫menes y redes pueden acumularse y ocupar espacio innecesario. Aqu√≠ te dejo algunos comandos esenciales para limpiar tu entorno de Docker.

### üîπ Detener y eliminar contenedores
Para detener todos los contenedores en ejecuci√≥n:
```sh
docker stop $(docker ps -q)
```
Para eliminar todos los contenedores detenidos:
```sh
docker rm $(docker ps -aq)
```

### üîπ Eliminar im√°genes innecesarias
Para eliminar im√°genes que ya no est√°n en uso:
```sh
docker image prune -a
```
Si necesitas eliminar una imagen espec√≠fica:
```sh
docker rmi nombre_imagen
```

### üîπ Limpiar vol√∫menes sin uso
Para eliminar vol√∫menes que no est√°n en uso:
```sh
docker volume prune
```
Si quieres eliminar un volumen espec√≠fico:
```sh
docker volume rm nombre_volumen
```

### üîπ Eliminar redes no utilizadas
Si tienes redes creadas que ya no usas:
```sh
docker network prune
```
Para eliminar una red espec√≠fica:
```sh
docker network rm nombre_red
```

### üîπ Limpiar todo el sistema Docker
Si quieres hacer una limpieza completa de contenedores, im√°genes, vol√∫menes y redes no utilizadas, usa:
```sh
docker system prune -a
```
**Advertencia:** Esto eliminar√° **todo lo que no est√© en uso por un contenedor en ejecuci√≥n**.


## üî• Comandos esenciales de Docker

| Comando | Descripci√≥n |
|---------|------------|
| `docker build -t <image_name> .` | Construye una imagen a partir de un Dockerfile |
| `docker run -p <host_port>:<container_port> <image_name>` | Ejecuta un contenedor basado en una imagen |
| `docker ps` | Lista los contenedores en ejecuci√≥n |
| `docker ps -a` | Lista todos los contenedores, incluidos los detenidos |
| `docker images` | Muestra las im√°genes descargadas |
| `docker logs <container>` | Muestra los logs de un contenedor |
| `docker stop <container>` | Detiene un contenedor en ejecuci√≥n |
| `docker rm <container>` | Elimina un contenedor detenido |
| `docker rm $(docker ps -aq)` | Elimina todos los contenedores detenidos |
| `docker rmi <image>` | Elimina una imagen espec√≠fica |
| `docker image prune -a` | Elimina todas las im√°genes sin uso |
| `docker volume ls` | Lista los vol√∫menes existentes |
| `docker volume prune` | Elimina los vol√∫menes sin uso |
| `docker network ls` | Lista las redes de Docker |
| `docker network prune` | Elimina las redes sin uso |
| `docker system prune -a` | Limpia im√°genes, contenedores, vol√∫menes y redes innecesarias |
| `docker-compose up -d` | Levanta los servicios en segundo plano |
| `docker-compose down` | Apaga y elimina los servicios definidos en `docker-compose.yml` |
| `docker-compose logs <service>` | Muestra los logs de un servicio en Docker Compose |
| `docker-compose build` | Construye las im√°genes especificadas en el archivo `docker-compose.yml` |
| `docker-compose ps` | Lista los servicios en ejecuci√≥n en Docker Compose |
| `docker-compose restart <service>` | Reinicia un servicio de Docker Compose |

Con esta lista de comandos esenciales, puedes administrar y limpiar tu entorno Docker de manera eficiente.


Como podras haberte dado cuenta ya, Docker y Docker Compose facilitan la creaci√≥n de entornos replicables y evitan problemas de dependencias, eliminando muchos problemas de configuracion, basta con levantar tus contenedores para estar listo para programar.

